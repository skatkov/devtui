package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/skatkov/devtui/cmd"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

func generateMarkdownForCommand(cmd *cobra.Command, isSubcommand bool) {
	// Skip generating separate files for subcommands
	if isSubcommand {
		return
	}

	// Determine the correct path to site/cli
	sitePath := "site/cli"
	if _, err := os.Stat("site"); os.IsNotExist(err) {
		sitePath = "../site/cli"
	}

	// Create a file
	file, err := os.Create(filepath.Join(sitePath, cmd.Name()+".md"))
	if err != nil {
		log.Fatal(err)
	}

	// Write front matter
	_, err = fmt.Fprintf(file, `---
title: %s
parent: CLI
---

`, cmd.Name())
	if err != nil {
		log.Fatal(err)
	}

	// Generate the markdown content for main command
	err = doc.GenMarkdown(cmd, file)
	if err != nil {
		log.Fatal(err)
	}

	// If the command has subcommands, add them to the same file
	if cmd.HasSubCommands() {
		for _, subCmd := range cmd.Commands() {
			// Skip help command
			if subCmd.Name() == "help" {
				continue
			}

			// Add a separator and subcommand documentation
			_, err = file.WriteString(string("\n---\n\n"))
			if err != nil {
				log.Fatal(err)
			}

			err = doc.GenMarkdown(subCmd, file)
			if err != nil {
				log.Fatal(err)
			}
		}
	}

	// Close the file before reading it back
	if err := file.Close(); err != nil {
		log.Fatal(err)
	}

	// Read the file to process it
	content, err := os.ReadFile(filepath.Join(sitePath, cmd.Name()+".md"))
	if err != nil {
		log.Fatal(err)
	}

	// Process content to remove duplicate title and clean up
	lines := strings.Split(string(content), "\n")
	processedLines := make([]string, 0, len(lines))
	inSeeAlso := false
	inCodeBlock := false
	codeBlockLines := []string{}
	lastSection := ""

	for _, line := range lines {
		if strings.HasPrefix(line, "# ") {
			// Skip the auto-generated title
			continue
		}
		if strings.HasPrefix(line, "###### Auto generated by") {
			// Skip the auto-generated footer
			continue
		}
		if strings.HasPrefix(line, "### SEE ALSO") {
			// Start skipping SEE ALSO section
			inSeeAlso = true
			continue
		}
		if inSeeAlso && (strings.HasPrefix(line, "### ") || strings.HasPrefix(line, "## ")) {
			// End of SEE ALSO section, start processing again
			inSeeAlso = false
		}
		if inSeeAlso {
			// Skip lines in SEE ALSO section
			continue
		}

		// Track current section
		if strings.HasPrefix(line, "### ") {
			lastSection = strings.TrimSpace(line)
		}

		// Handle code blocks
		if strings.TrimSpace(line) == "```" && !inCodeBlock {
			// Start of code block
			inCodeBlock = true
			// Add bash language hint for Examples and Synopsis sections
			if lastSection == "### Examples" || lastSection == "### Synopsis" {
				processedLines = append(processedLines, "```bash")
			} else {
				processedLines = append(processedLines, "```")
			}
			continue
		}
		if strings.TrimSpace(line) == "```" && inCodeBlock {
			// End of code block - process collected lines
			for _, codeLine := range codeBlockLines {
				// Remove leading whitespace for Examples sections only
				if lastSection == "### Examples" {
					trimmed := strings.TrimLeft(codeLine, " \t")
					if trimmed != "" {
						processedLines = append(processedLines, trimmed)
					}
				} else {
					processedLines = append(processedLines, codeLine)
				}
			}
			processedLines = append(processedLines, "```")
			inCodeBlock = false
			codeBlockLines = []string{}
			continue
		}
		if inCodeBlock {
			// Collect lines inside code block
			codeBlockLines = append(codeBlockLines, line)
			continue
		}

		processedLines = append(processedLines, line)
	}

	// Write the processed content back
	err = os.WriteFile(filepath.Join(sitePath, cmd.Name()+".md"), []byte(strings.Join(processedLines, "\n")), 0o644)
	if err != nil {
		log.Fatal(err)
	}
}

func GenerateCLIDocumentation() {
	rootCmd := cmd.GetRootCmd()

	cmds := rootCmd.Commands()
	for _, cmd := range cmds {
		// Skip version command
		if cmd.Name() == "version" {
			continue
		}

		// Generate documentation for the command (including subcommands)
		generateMarkdownForCommand(cmd, false)
	}
}
